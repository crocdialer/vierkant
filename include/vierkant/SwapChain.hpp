//
// Created by crocdialer on 10/1/18.
//

#pragma once

#include "Device.hpp"
#include "Image.hpp"
#include "Framebuffer.hpp"

namespace vierkant {

class SwapChain
{
public:

    static constexpr uint32_t max_frames_in_flight = 2;

    /**
     * @brief   sync_objects_t is a helper struct to bundle synchronization data for the SwapChain
     */
    struct sync_objects_t
    {
        VkSemaphore image_available = VK_NULL_HANDLE;

        VkSemaphore render_finished = VK_NULL_HANDLE;

        VkFence in_flight = VK_NULL_HANDLE;

        uint32_t frame_index = 0;
    };

    SwapChain() = default;

    /**
     * @brief   Construct a new SwapChain
     *
     * @param   device          handle for the vierkant::Device to create the SwapChain with
     * @param   surface         handle for a VkSurfaceKHR to create the SwapChain for
     * @param   num_samples     an optional VkSampleCountFlagBits value to request multisampling
     */
    SwapChain(DevicePtr device, VkSurfaceKHR surface,
              VkSampleCountFlagBits num_samples = VK_SAMPLE_COUNT_1_BIT);

    SwapChain(SwapChain &&other) noexcept;

    SwapChain(const SwapChain &other) = delete;

    ~SwapChain();

    SwapChain &operator=(SwapChain other);

    /**
     * @brief       Aquire the next image from the SwapChain
     *
     * @param[out]  image_index pointer to write out the aquired image's index.
     * @param       timeout     optinal timeout in ms
     * @return      the VkResult generated by vkAcquireNextImageKHR
     */
    VkResult aquire_next_image(uint32_t *image_index,
                               uint64_t timeout = std::numeric_limits<uint64_t>::max());

    /**
     * @brief   submit the current SwapChain-image to the presentation queue and update frame-indices
     * @return  the VkResult generated by vkQueuePresentKHR
     */
    VkResult present();

    /**
     * @return  handle for the managed VkSwapchainKHR
     */
    VkSwapchainKHR handle() const { return m_swap_chain; }

    /**
     * @return  handle for the device
     */
    DevicePtr device() const { return m_device; }

    /**
     * @return  handle for the shared VkRenderPass, used by all contained Framebuffers
     */
    VkRenderPass renderpass() const;

    /**
     * @return  a reference for the contained array of Framebuffers
     */
    const std::vector<vierkant::Framebuffer> &framebuffers() const { return m_framebuffers; }

    /**
     * @return  a reference for array of SwapChain-Images
     */
    const std::vector<vierkant::ImagePtr> &images() const { return m_images; }

    /**
     * @return  the VkExtent2D (size) of the SwapChain-Images
     */
    const VkExtent2D &extent() const { return m_extent; }

    /**
     * @return  the VkSampleCountFlagBits stating the number of samples per pixel (MSAA)
     */
    VkSampleCountFlagBits sample_count() const { return m_num_samples; }

    /**
     * @return  the current image index inside the SwapChain
     */
    uint32_t image_index() const { return m_swapchain_image_index; }

    /**
     * @return  a reference to the current sync_objects_t
     */
    const sync_objects_t &sync_objects() const { return m_sync_objects[m_current_frame_index]; };

    friend void swap(SwapChain &lhs, SwapChain &rhs);

    inline explicit operator bool() const { return static_cast<bool>(m_swap_chain); };

private:

    void create_framebuffers();

    void create_sync_objects();

    DevicePtr m_device;

    VkSampleCountFlagBits m_num_samples = VK_SAMPLE_COUNT_1_BIT;

    VkSwapchainKHR m_swap_chain = VK_NULL_HANDLE;

    std::vector<vierkant::ImagePtr> m_images;

    std::vector<vierkant::Framebuffer> m_framebuffers;

    VkFormat m_color_format = VK_FORMAT_UNDEFINED;

    VkFormat m_depth_format = VK_FORMAT_UNDEFINED;

    VkExtent2D m_extent = {};

    std::vector<sync_objects_t> m_sync_objects;

    uint32_t m_current_frame_index = 0;

    uint32_t m_swapchain_image_index = 0;
};

}//namespace vulkan