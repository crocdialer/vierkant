//
// Created by crocdialer on 10/1/18.
//

#pragma once

#include "vierkant/Device.hpp"
#include "vierkant/Framebuffer.hpp"
#include "vierkant/Image.hpp"

namespace vierkant
{

class SwapChain
{
public:
    static constexpr uint32_t max_frames_in_flight = 3;

    struct acquire_image_result_t
    {
        uint32_t image_index = 0;
        VkResult result = VK_ERROR_UNKNOWN;
        VkSemaphore image_available = VK_NULL_HANDLE;
        VkSemaphore render_finished = VK_NULL_HANDLE;
    };

    SwapChain() = default;

    /**
     * @brief   Construct a new SwapChain
     *
     * @param   device          handle for the vierkant::Device to create the SwapChain with
     * @param   surface         handle for a VkSurfaceKHR to create the SwapChain for
     * @param   num_samples     an optional VkSampleCountFlagBits value to request multisampling
     * @param   use_vsync       flag to request vertical synchronisation (cap fps to refresh rate)
     */
    SwapChain(DevicePtr device,
              VkSurfaceKHR surface,
              VkSampleCountFlagBits num_samples = VK_SAMPLE_COUNT_1_BIT,
              bool use_vsync = true,
              bool use_hdr = false);

    SwapChain(SwapChain &&other) noexcept;

    SwapChain(const SwapChain &other) = delete;

    ~SwapChain();

    SwapChain &operator=(SwapChain other);

    /**
     * @brief       Acquire the next image from the SwapChain
     *
     * @param       timeout     optional timeout in nanoseconds
     * @return      a acquire_image_result_t struct, grouping all return-params.
     */
    acquire_image_result_t acquire_next_image(uint64_t timeout = std::numeric_limits<uint64_t>::max());

    /**
     * @brief   submit the current SwapChain-image to the presentation queue and update frame-indices
     * @return  the VkResult generated by vkQueuePresentKHR
     */
    VkResult present();

    /**
     * @return  handle for the managed VkSwapchainKHR
     */
    [[nodiscard]] VkSwapchainKHR handle() const{ return m_swap_chain; }

    /**
     * @return  handle for the device
     */
    [[nodiscard]] DevicePtr device() const{ return m_device; }

    /**
     * @return  handle for the shared VkRenderPass, used by all contained Framebuffers
     */
    [[nodiscard]] VkRenderPass renderpass() const;

    /**
     * @return  a reference for the contained array of Framebuffers
     */
    std::vector<vierkant::Framebuffer> &framebuffers(){ return m_framebuffers; }

    vierkant::Framebuffer &current_framebuffer(){ return m_framebuffers[m_swapchain_image_index]; }

    /**
     * @return  a reference for array of SwapChain-Images
     */
    [[nodiscard]] const std::vector<vierkant::ImagePtr> &images() const{ return m_images; }

    /**
     * @return  the VkExtent2D (size) of the SwapChain-Images
     */
    [[nodiscard]] const VkExtent2D &extent() const{ return m_extent; }

    /**
     * @return  the VkSampleCountFlagBits stating the number of samples per pixel (MSAA)
     */
    [[nodiscard]] VkSampleCountFlagBits sample_count() const{ return m_num_samples; }

    /**
     * @return  a flag indicating if vertical synchronization is used
     */
    [[nodiscard]] bool v_sync() const{ return m_use_v_sync; }

    /**
     * @return  the current image index inside the SwapChain
     */
    [[nodiscard]] uint32_t image_index() const{ return m_swapchain_image_index; }

    friend void swap(SwapChain &lhs, SwapChain &rhs);

    inline explicit operator bool() const{ return static_cast<bool>(m_swap_chain); };

private:

    /**
     * @brief   sync_objects_t is a helper struct to bundle synchronization data for the SwapChain
     */
    struct sync_objects_t
    {
        VkSemaphore image_available = VK_NULL_HANDLE;
        VkSemaphore render_finished = VK_NULL_HANDLE;
    };

    void create_framebuffers();

    void create_sync_objects();

    DevicePtr m_device;

    VkSampleCountFlagBits m_num_samples = VK_SAMPLE_COUNT_1_BIT;

    VkSwapchainKHR m_swap_chain = VK_NULL_HANDLE;

    bool m_use_v_sync = true;

    std::vector<vierkant::ImagePtr> m_images;

    std::vector<vierkant::Framebuffer> m_framebuffers;

    VkFormat m_color_format = VK_FORMAT_UNDEFINED;

    VkFormat m_depth_format = VK_FORMAT_UNDEFINED;

    VkExtent2D m_extent = {};

    std::vector<sync_objects_t> m_sync_objects;

    acquire_image_result_t m_last_acquired_image = {};

    uint32_t m_current_frame_index = 0;

    uint32_t m_swapchain_image_index = 0;
};

}// namespace vierkant