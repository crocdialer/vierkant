#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable

#include "ray_common.glsl"

#define RADIANCE 0
#define NORMALS 1
#define POSITIONS 2
#define ACCUMULATED_RADIANCE 3

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;

layout(binding = 1, set = 0, rgba32f) uniform image2D out_images[4];

layout(binding = 2, set = 0) uniform CameraProperties
{
    mat4 viewInverse;
    mat4 projInverse;
} cam;

layout(push_constant) uniform PushConstants
{
    push_constants_t push_constants;
};

layout(location = 0) rayPayloadEXT payload_t payload;

struct trace_result_t
{
    vec3 radiance;
    vec3 normal;
    vec3 position;
};

trace_result_t trace(vec2 coord, vec2 size)
{
    trace_result_t trace_result;

    // State of the random number generator.
    uint rngState = rng_seed(push_constants.random_seed);

    vec3 camera_position = (cam.viewInverse * vec4(0, 0, 0, 1)).xyz;

    // The sum of the colors of all of the samples.
    trace_result.radiance = vec3(0);

    // Limit the kernel to trace at most 64 samples.
    const int NUM_SAMPLES = 1;

    float sample_offset = rng_float(rngState);

    // sample random dirctions around the pixel's center
    //           1
    //    .------+------.
    //    |      |      |
    // -a + ---- 0 ---- + a
    //    |      |      |
    //    '------+------'
    //          -1
    for (int sampleIdx = 0; sampleIdx < NUM_SAMPLES; sampleIdx++)
    {
        // random+stratified sampling
        const vec2 randomPixelCenter = coord + fract(Hammersley(sampleIdx, NUM_SAMPLES) + vec2(sample_offset));
        const vec2 inUV = randomPixelCenter / size;
        vec2 d = inUV * 2.0 - 1.0;

        // ray direction
        vec3 target = (cam.projInverse * vec4(d.x, d.y, 1, 1)).xyz;
        vec3 direction = (cam.viewInverse * vec4(normalize(target.xyz), 0)).xyz;

        // next ray
        Ray ray = Ray(camera_position, direction);

        float tmin = 0.0001;
        float tmax = 10000.0;

        const uint max_depth = 3;

        vec3 beta = vec3(1);
        float pdf = FLOAT_MAX;
        vec3 path_radiance = vec3(0);

        // trace a path
        for (int i = 0; i < max_depth; i++)
        {
            payload.stop = false;
            payload.radiance = path_radiance;
            payload.beta = beta;
            payload.pdf = pdf;
            payload.ray = ray;

            const uint ray_flags = gl_RayFlagsOpaqueEXT | gl_RayFlagsCullBackFacingTrianglesEXT;

            // trace one ray
            traceRayEXT(topLevelAS,     // acceleration structure
                        ray_flags,      // rayflags
                        0xff,           // cullMask
                        0,              // sbtRecordOffset
                        0,              // sbtRecordStride
                        0,              // missIndex
                        ray.origin,     // ray origin
                        tmin,           // ray min range
                        ray.direction,  // ray direction
                        tmax,           // ray max range
                        0);             // payload (location = 0)

            ray = payload.ray;
            beta = payload.beta;
            pdf = payload.pdf;
            path_radiance = payload.radiance;

            if(i == 0)
            {
                trace_result.normal = payload.normal;
                trace_result.position = payload.position;
            }

            // nothing hit, end recursion
            if (payload.stop){ break; }
        }

        trace_result.radiance += path_radiance;
    }

    trace_result.radiance /= NUM_SAMPLES;
    return trace_result;
}

void main()
{
    trace_result_t trace_result = trace(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy);
    vec4 accumulated_radiance = vec4(trace_result.radiance, 1);

    if (push_constants.batch_index != 0)
    {
        uint size = push_constants.batch_index;
        accumulated_radiance += size * imageLoad(out_images[ACCUMULATED_RADIANCE], ivec2(gl_LaunchIDEXT.xy));
        accumulated_radiance /= size + 1;
    }
    if(any(isinf(accumulated_radiance)) || any(isnan(accumulated_radiance))){ accumulated_radiance = vec4(0, 0, 0, 1); }

    imageStore(out_images[RADIANCE], ivec2(gl_LaunchIDEXT.xy), vec4(trace_result.radiance, 1.0));
    imageStore(out_images[NORMALS], ivec2(gl_LaunchIDEXT.xy), vec4(trace_result.normal, 0.0));
    imageStore(out_images[POSITIONS], ivec2(gl_LaunchIDEXT.xy), vec4(trace_result.position, 0.0));
    imageStore(out_images[ACCUMULATED_RADIANCE], ivec2(gl_LaunchIDEXT.xy), accumulated_radiance);
}
