#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable

#include "../utils/random.glsl"
#include "../utils/bsdf.glsl"
#include "ray_common.glsl"

#define RADIANCE 0
#define NORMALS 1
#define POSITIONS 2
#define ACCUMULATED_RADIANCE 3

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;

layout(binding = 1, set = 0, rgba32f) uniform image2D out_images[4];

layout(binding = 2, set = 0) uniform CameraProperties
{
    camera_ubo_t cam;
};

layout(push_constant) uniform PushConstants
{
    push_constants_t push_constants;
};

layout(location = MISS_INDEX_DEFAULT) rayPayloadEXT payload_t payload;
layout(location = MISS_INDEX_SHADOW) rayPayloadEXT shadow_payload_t payload_shadow;

struct trace_result_t
{
    vec3 radiance;
    vec3 normal;
    vec3 position;
};

trace_result_t trace(vec2 coord, vec2 size)
{
    trace_result_t trace_result;

    // init random number generator.
    uint rng_state = xxhash32(push_constants.random_seed, gl_LaunchSizeEXT.x * gl_LaunchIDEXT.y + gl_LaunchIDEXT.x);

    // The sum of the colors of all of the samples.
    trace_result.radiance = vec3(0);

    float sample_offset = 2 * rnd(rng_state) - 1;

    // cone spread_angle
    float spread_angle = atan(2.0 * tan(cam.fov / 2.0) / size.y);

    // sample random dirctions around the pixel's center
    //           1
    //    .------+------.
    //    |      |      |
    // -a + ---- 0 ---- + a
    //    |      |      |
    //    '------+------'
    //          -1
    for (int sampleIdx = 0; sampleIdx < push_constants.num_samples; sampleIdx++)
    {
        // random+stratified sampling
        const vec2 randomPixelCenter = coord + fract(Hammersley(sampleIdx, push_constants.num_samples) + vec2(sample_offset));
        const vec2 inUV = randomPixelCenter / size;
        vec2 d = inUV * 2.0 - 1.0;

        // lens-offset and ray-origin
        vec2 Xi = vec2(rnd(rng_state), rnd(rng_state));
        vec3 lens_offset = vec3(cam.aperture / 2.0 * sample_unit_disc(Xi), 0.0);
        vec3 origin = (cam.view_inverse * vec4(lens_offset, 1)).xyz;

        // ray direction
        vec3 target_dir = normalize((cam.projection_inverse * vec4(d.x, d.y, 1, 1)).xyz);
        vec3 fpoint = target_dir * cam.focal_distance / abs(target_dir.z);
        vec3 direction = normalize(mat3(cam.view_inverse) * (fpoint - lens_offset));

        // next ray + cone
        Ray ray = Ray(origin, direction);
        RayCone cone = RayCone(spread_angle, 0.0);

        float tmin = 0.0001;
        float tmax = 10000.0;

        // assumes we start in air
        float ior = 1.0;
        vec3 absorption = vec3(0);
        bool inside_media = false;

        vec3 beta = vec3(1);
        vec3 path_radiance = vec3(0);

        // trace a path
        for (uint i = 0; i < push_constants.max_trace_depth; i++)
        {
            rng_state = xxhash32(rng_state, i);

            payload.rng_state = rng_state;
            payload.depth = i;
            payload.stop = false;
            payload.radiance = path_radiance;
            payload.beta = beta;
            payload.ior = ior;
            payload.absorption = absorption;
            payload.inside_media = inside_media;
            payload.ray = ray;
            payload.cone = cone;

            const uint ray_flags = gl_RayFlagsOpaqueEXT | (inside_media ? 0 : gl_RayFlagsCullBackFacingTrianglesEXT);

            // trace one ray
            traceRayEXT(topLevelAS,         // acceleration structure
                        ray_flags,          // rayflags
                        0xff,               // cullMask
                        0,                  // sbtRecordOffset
                        0,                  // sbtRecordStride
                        MISS_INDEX_DEFAULT, // missIndex
                        ray.origin,         // ray origin
                        tmin,               // ray min range
                        ray.direction,      // ray direction
                        tmax,               // ray max range
                        MISS_INDEX_DEFAULT);// payload-location

            cone = payload.cone;
            ray = payload.ray;
            beta = payload.beta;
            ior = payload.ior;
            absorption = payload.absorption;
            inside_media = payload.inside_media;
            path_radiance = payload.radiance;

            if(i == 0)
            {
                trace_result.normal = payload.normal;
                trace_result.position = payload.position;
            }

            // nothing hit, end recursion
            if (payload.stop){ break; }
        }

        trace_result.radiance += path_radiance;
    }

    trace_result.radiance /= float(push_constants.num_samples);
//    if(any(isinf(trace_result.radiance)) || any(isnan(trace_result.radiance))){ trace_result.radiance = vec3(0); }
    return trace_result;
}

void main()
{
    trace_result_t trace_result = trace(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy);
    vec4 accumulated_radiance = vec4(trace_result.radiance, 1);

    if (push_constants.batch_index != 0)
    {
        uint size = push_constants.batch_index;
        accumulated_radiance += size * imageLoad(out_images[ACCUMULATED_RADIANCE], ivec2(gl_LaunchIDEXT.xy));
        accumulated_radiance /= size + 1;
    }

//    imageStore(out_images[RADIANCE], ivec2(gl_LaunchIDEXT.xy), vec4(trace_result.radiance, 1.0));
    imageStore(out_images[NORMALS], ivec2(gl_LaunchIDEXT.xy), vec4(trace_result.normal, 0.0));
//    imageStore(out_images[POSITIONS], ivec2(gl_LaunchIDEXT.xy), vec4(trace_result.position, 0.0));
    imageStore(out_images[ACCUMULATED_RADIANCE], ivec2(gl_LaunchIDEXT.xy), accumulated_radiance);
}
