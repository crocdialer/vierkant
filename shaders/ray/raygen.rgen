#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable

#include "../utils/random.glsl"
#include "../utils/bsdf.glsl"
#include "ray_common.glsl"
#include "reservoir.glsl"

#define RADIANCE 0
#define NORMALS 1

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;

layout(binding = 1, set = 0, rgba32f) uniform image2D out_images[2];

layout(binding = 2, r16ui) writeonly uniform uimage2D out_object_ids;

layout(binding = 3, set = 0) uniform CameraProperties
{
    camera_ubo_t cam;
};

layout(push_constant) uniform PushConstants
{
    push_constants_t push_constants;
};

layout(location = MISS_INDEX_DEFAULT) rayPayloadEXT payload_t payload;

struct trace_result_t
{
    vec3 radiance;
    float coverage;
    vec3 normal;
    vec3 position;
    uint entity_index;
};

trace_result_t trace(vec2 coord, vec2 size)
{
    trace_result_t trace_result;

    // init random number generator.
    uint rng_state = xxhash32(push_constants.random_seed, gl_LaunchSizeEXT.x * gl_LaunchIDEXT.y + gl_LaunchIDEXT.x);

    // sum radiance and coverage for all samples.
    trace_result.radiance = vec3(0);
    trace_result.coverage = 0.0;

    float sample_offset = 2 * rnd(rng_state) - 1;

    // cone spread_angle
    float spread_angle = atan(2.0 * tan(cam.fov / 2.0) / size.y);

    // sample random dirctions around the pixel's center
    //           1
    //    .------+------.
    //    |      |      |
    // -a + ---- 0 ---- + a
    //    |      |      |
    //    '------+------'
    //          -1
    for (int sampleIdx = 0; sampleIdx < push_constants.num_samples; sampleIdx++)
    {
        // random+stratified sampling
        const vec2 randomPixelCenter = coord + fract(Hammersley(sampleIdx,
                                                                push_constants.num_samples) + vec2(sample_offset));
        const vec2 inUV = randomPixelCenter / size;
        vec2 d = inUV * 2.0 - 1.0;

        // lens-offset and ray-origin
        vec2 Xi = vec2(rnd(rng_state), rnd(rng_state));
        vec3 lens_offset = vec3(cam.aperture / 2.0 * sample_unit_disc(Xi), 0.0);
        vec3 origin = (cam.view_inverse * vec4(lens_offset, 1)).xyz;

        // ray direction
        vec3 target_dir = normalize((cam.projection_inverse * vec4(d.x, d.y, 1, 1)).xyz);
        vec3 fpoint = target_dir * cam.focal_distance / abs(target_dir.z);
        vec3 direction = normalize(mat3(cam.view_inverse) * (fpoint - lens_offset));

        // next ray + cone
        Ray ray = Ray(origin, direction, 0.0001, 10000.0);
        RayCone cone = RayCone(spread_angle, 0.0);

        // assumes we start in air
        float ior = 1.0;
        vec3 sigma_t = vec3(0);
        bool transmission = false;

        vec3 beta = vec3(1);
        vec3 path_radiance = vec3(0);

        // trace a path
        for (uint i = 0; i < push_constants.max_trace_depth; i++)
        {
            rng_state = xxhash32(rng_state, i);

            payload.rng_state = rng_state;
            payload.depth = i;
            payload.stop = false;
            payload.radiance = path_radiance;
            payload.beta = beta;
            payload.ior = ior;
            payload.sigma_t = sigma_t;
            payload.transmission = transmission;
            payload.ray = ray;
            payload.cone = cone;

            const uint ray_flags = gl_RayFlagsOpaqueEXT | (transmission ? 0 : gl_RayFlagsCullBackFacingTrianglesEXT);

            // trace one ray
            traceRayEXT(topLevelAS,         // acceleration structure
                        ray_flags,          // rayflags
                        0xff,               // cullMask
                        0,                  // sbtRecordOffset
                        0,                  // sbtRecordStride
                        MISS_INDEX_DEFAULT, // missIndex
                        ray.origin,         // ray origin
                        ray.tmin,           // ray min range
                        ray.direction,      // ray direction
                        ray.tmax,           // ray max range
                        MISS_INDEX_DEFAULT);// payload-location

            cone = payload.cone;
            ray = payload.ray;
            beta = payload.beta;
            ior = payload.ior;
            sigma_t = payload.sigma_t;
            transmission = payload.transmission;
            path_radiance = payload.radiance;

            if(i == 0)
            {
                trace_result.entity_index = payload.entity_index;
                trace_result.normal = payload.normal;
                trace_result.position = payload.position;
            }

            // nothing hit, end recursion
            if (payload.stop){ break; }
        }

        trace_result.radiance += payload.radiance;
        trace_result.coverage = max(trace_result.coverage, payload.depth > 0 ? 1.0 : 0.0);
    }
    trace_result.radiance /= float(push_constants.num_samples);
    return trace_result;
}

void main()
{
    trace_result_t trace_result = trace(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy);
    vec4 accumulated_radiance = vec4(trace_result.radiance, smoothstep(0, 1, trace_result.coverage));

    if(push_constants.batch_index == 0)
    {
        imageStore(out_images[NORMALS], ivec2(gl_LaunchIDEXT.xy), vec4(trace_result.normal, 0.0));
        imageStore(out_object_ids, ivec2(gl_LaunchIDEXT.xy), uvec4(MAX_UINT16 - trace_result.entity_index));
    }
    else
    {
        uint size = push_constants.batch_index;
        accumulated_radiance += size * imageLoad(out_images[RADIANCE], ivec2(gl_LaunchIDEXT.xy));
        accumulated_radiance /= size + 1;
    }
    imageStore(out_images[RADIANCE], ivec2(gl_LaunchIDEXT.xy), accumulated_radiance);
}
