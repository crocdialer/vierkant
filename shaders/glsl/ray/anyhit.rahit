#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_buffer_reference2: require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types: require
#extension GL_GOOGLE_include_directive : enable

#include "../utils/random.glsl"

// for material_t
#include "types.glsl"

#include "ray_common.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;

layout(binding = 1, set = 0) uniform TraceData
{
    trace_data_t trace_data;
};

layout(binding = 2) uniform sampler2D u_textures[];

// the ray-payload written here
layout(location = MISS_INDEX_DEFAULT) rayPayloadInEXT payload_t payload;

// builtin barycentric coords
hitAttributeEXT vec2 attribs;

void main()
{
    uint rng_state = payload.rng_state;

    // entry aka instance
    nonuniformEXT entry_t entry = trace_data.entries.v[nonuniformEXT(gl_InstanceCustomIndexEXT)];
    nonuniformEXT material_t material = trace_data.materials.v[nonuniformEXT(entry.material_index)];

    if(!material.null_surface && (material.blend_mode == BLEND_MODE_MASK || material.blend_mode == BLEND_MODE_BLEND))
    {
        // albedo
        if((material.texture_type_flags & TEXTURE_TYPE_COLOR) != 0)
        {
            // triangle indices
            ivec3 ind = ivec3(trace_data.index_buffers.v[entry.buffer_index].v[entry.base_index + 3 * gl_PrimitiveID + 0],
                              trace_data.index_buffers.v[entry.buffer_index].v[entry.base_index + 3 * gl_PrimitiveID + 1],
                              trace_data.index_buffers.v[entry.buffer_index].v[entry.base_index + 3 * gl_PrimitiveID + 2]);

            // triangle vertices
            Triangle t = Triangle(unpack(trace_data.vertex_buffers.v[entry.buffer_index].v[entry.vertex_offset + ind.x]),
                                  unpack(trace_data.vertex_buffers.v[entry.buffer_index].v[entry.vertex_offset + ind.y]),
                                  unpack(trace_data.vertex_buffers.v[entry.buffer_index].v[entry.vertex_offset + ind.z]));

            // interpolated vertex
            const vec3 barycentric = vec3(1.0f - attribs.x - attribs.y, attribs.x, attribs.y);
            vec2 tex_coord = t.v0.tex_coord * barycentric.x + t.v1.tex_coord * barycentric.y + t.v2.tex_coord * barycentric.z;

            material.color *= texture(u_textures[material.albedo_index], tex_coord);
        }
        material.color = trace_data.params.disable_material ? vec4(vec3(.8), 1.0) : material.color;

        if(material.blend_mode == BLEND_MODE_MASK && material.color.a < material.alpha_cutoff)
        {
            ignoreIntersectionEXT;
        }
        if(material.blend_mode == BLEND_MODE_BLEND && material.color.a < rnd(rng_state))
        {
            ignoreIntersectionEXT;
        }
    }
}
