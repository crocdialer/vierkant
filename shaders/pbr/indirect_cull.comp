#version 460

#extension GL_GOOGLE_include_directive : require

struct draw_cull_data_t
{
    mat4 view;
    float P00, P11, znear, zfar;// symmetric projection parameters
    vec4 frustum;// data for left/right/top/bottom frustum planes

    vec2 pyramid_size;// depth pyramid size in texels

    uint draw_count;

    bool culling_enabled;
    bool lod_enabled;
    bool occlusion_enabled;
    bool distance_cull;
};

//typedef struct VkDrawIndirectCommand {
//    uint32_t    vertexCount;
//    uint32_t    instanceCount;
//    uint32_t    firstVertex;
//    uint32_t    firstInstance;
//} VkDrawIndirectCommand;

struct IndexedIndirectCommand
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;

    uint object_index;
    vec4 sphere_bounds;
};

layout(binding = 0) uniform sampler2D u_depth_pyramid;

layout(std140, binding = 1) uniform culldata_ubo_t
{
    draw_cull_data_t cull_data;
};

// input draw indirect buffer
layout(binding = 2) readonly buffer DrawBufferIn
{
    IndexedIndirectCommand in_draw_data[];
};

// output draw indirect buffer
layout(binding = 3) writeonly buffer DrawBufferOut
{
    IndexedIndirectCommand out_draw_data[];
};

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

void main()
{
    uint gid = gl_GlobalInvocationID.x;
    if(gid >= cull_data.draw_count){ return; }

    // simple pass-through
    IndexedIndirectCommand draw = in_draw_data[gid];

    bool visible = true;
//    if(cull_data.culling_enabled && (gid % 2) == 0){ draw.instanceCount = 0; }
    visible = visible && !(cull_data.distance_cull && (-draw.sphere_bounds.z + draw.sphere_bounds.w) > cull_data.zfar);


    if(!visible){ draw.instanceCount = 0; }
    out_draw_data[gid] = draw;
}