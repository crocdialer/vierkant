#version 460

#extension GL_GOOGLE_include_directive : require

struct draw_cull_data_t
{
    mat4 view;
    float P00, P11, znear, zfar; // symmetric projection parameters
    vec4 frustum; // data for left/right/top/bottom frustum planes

    vec2 pyramid_size; // depth pyramid size in texels

    uint draw_count;

    bool culling_enabled;
    bool lod_enabled;
    bool occlusion_enabled;
    bool distance_cull;

    bool AABB_check;
    vec3 aabb_min;
    vec3 aabb_max;
};

//typedef struct VkDrawIndirectCommand {
//    uint32_t    vertexCount;
//    uint32_t    instanceCount;
//    uint32_t    firstVertex;
//    uint32_t    firstInstance;
//} VkDrawIndirectCommand;

struct VkDrawIndexedIndirectCommand
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
};

layout(binding = 0) uniform sampler2D u_depth_pyramid;

layout(std140, binding = 1) uniform culldata_ubo_t
{
    draw_cull_data_t cull_data;
};

// input draw indirect buffer
layout(binding = 2) readonly buffer DrawBufferIn
{
    VkDrawIndexedIndirectCommand in_draw_data[];
};

// output draw indirect buffer
layout(binding = 3) writeonly buffer DrawBufferOut
{
    VkDrawIndexedIndirectCommand out_draw_data[];
};

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

void main()
{
    uint gid = gl_GlobalInvocationID.x;
    if(gid >= cull_data.draw_count){ return; }

    // TODO: bounds sanity-check

    // simple pass-through
    VkDrawIndexedIndirectCommand cmd;
    cmd.indexCount = 0;
    cmd.instanceCount = 0;
    cmd.firstIndex = 0;
    cmd.vertexOffset = 0;
    cmd.firstInstance = 0;

    if (cull_data.culling_enabled){ out_draw_data[gid] = cmd; }
    else { out_draw_data[gid] = in_draw_data[gid]; }
}